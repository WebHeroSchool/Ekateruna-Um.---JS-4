# Лучшие практики JS #

###### Использование литералов для примитивных значений ######

В JavaScript существует несколько способов объявления примитивных переменных. Примитивные переменные включают в себя переменные любого типа, но объекты к ним не относятся. Одним из способов является использование литералов, например:

    let x = 1;
    let y = true;
    let z = ' ';

В приведенном выше коде устанавливается литеральное значение number, boolean и string каждой переменной. В качестве альтернативы возможно написать:

    let x = new Number(1);
    let y = new Boolean(true);
    let z = new String('');

Можно также написать:

    let x = Number(1);
    let y = Boolean(true);
    let z = String('');

Из трех способов объявления примитивных переменных, указанных выше, некоторые оказываются лучше других. Лучшими из них являются непосредственно объявление через литералы либо использование функций, как показано в третьем примере.

Почему бы не использовать конструктор для создания переменных с примитивными значениями? Во-первых, то, что определено при помощи оператора new, будет иметь тип object даже в том случае, если значение его примитивно. Из-за этого становится сложнее сравнивать объекты. Например, если написать:

    new String('foo') === new String('foo');

Результатом подобного строгого сравнения будет false, потому что оба сравниваемых элемента имеют тип object, а два объекта в JavaScript не могут ссылаться на одно и то же место в памяти.

Нестрогое сравнение через == приведет к аналогичному результату по той же причине. Поскольку оба элемента имеют тип object, труднее определить, являются ли их значения на самом деле строковыми, логическими или числовыми.

Два других способа значительно лучше, поскольку они будут возвращать правильный тип. Например, следующее объявление переменной вернет тип number:

    let x = 2;
    console.log(typeof x);

Это также относится к другим примитивным типам данных. Нет никаких причин использовать оператор new для объявления переменных с примитивными значениями. Это только усложняет жизнь.

Использование new также замедляет работу интерпретатора JavaScript, поскольку он должен выполнить на одну операцию больше, чем действительно необходимо для того, чтобы объявить переменную с примитивным значением. Функции Number, String и Boolean полезны для преобразования типов из одного в другой. Например, есть:

    let x = '2';

Следовательно, можно преобразовать строковый тип значения объявленной переменной в числовой при помощи функции Number:

    let y = Number(x);

###### Используйте литералы для объявления объектов ######

Для объявления большинства объектов существуют специальные литералы. Например, объявить массив можно при помощи литерала [...]. Регулярные выражения могут быть объявлены при помощи специальных паттернов со слешами. При объявлении функции возможно использование ключевого слова function или стрелки ->.

Иногда определение значений с помощью конструкторов приводит к путанице. Например, массивы имеют как бы два конструктора. Один из них имеет один параметр, в качестве которого выступает длина массива (целое неотрицательное число). Другому в качестве параметров передаются элементы массива (список), записанные через запятую.

Это означает, что Array(1) будет возвращать пустой массив с длиной, равной 1, и без содержимого, а Array(1, 2, 3) вернет массив, содержащий три элемента [1, 2, 3]. Как видно из приведенных примеров, объявление массива через конструктор вносит неясность.

Для определения функций существуют ключевое слово function и конструктор Function.

Использование конструктора Function не представляет никакого смысла. В качестве параметров рассматриваемый конструктор принимает строки, т.е. и аргументы создаваемой функции, и сам ее код — все это должно передаваться в конструктор строками через запятую. Это приводит к повышенной уязвимости кода, к возникновению проблем безопасности. Да и писать код в виде строки — это боль.

Ключевое слово function гораздо понятнее. Объявление функции с его помощью или с использованием стрелки позволяет писать код, распознаваемый текстовыми редакторами как код функции. Таким образом, если нет необходимости в динамическом создании новых функций, объявлять их через конструктор Function не стоит.

Аналогично конструктор RegExp хорош для динамического конструирования новых регулярных выражений, но в остальном объявление их через конструктор не имеет никаких преимуществ перед их объявлением с помощью литерала. Объявления через литерал и конструктор одинаковы для статических выражений, поэтому в данном случае использование конструктора допустимо.

Конструктор Object просто заставляет вводить больше кода, чем при объявлении объектов через литералы, в остальном эти способы одинаковы. Это означает, что использовать конструктор для объявления объектов бессмысленно.

###### Автоматическое преобразование типов ######

Для преобразования примитивных значений, таких как числа, булевы значения и строки, можно использовать функции Number, Boolean и String, соответственно. Необходимо только передать нужные данные в эти функции, но лучше использовать автоматическое преобразование. Примеры ниже.

В JavaScript можно приводить примитивные значения к различным типам данных в зависимости от контекста.

    1 == '1'

 строка '1' будет преобразована в число.

    1 + '1'

 число 1 будет преобразовано в строку '1' и запись вернет '11'.

    1 — '1'

 строка '1' преобразуется в число и запись вернет 0.

    1 — 'a'

 вернет NaN, поскольку происходит вычитание строки с нечисловым контекстом из числа. В логическом выражении переменные или внутренние значения вычисляются до их истинных или ложных значений. Значения, возвращающие false, включают в себя: 0, null, undefined, '' (пустая строка), false, NaN. Все остальные значения возвращают true.

    0 || undefined || null || 1

результатом этой записи будет 1. Интерпретатор JavaScript определит все значения, которые возвращают false, и в итоге вернет единственное истинное значение  —  1.

Также можно использовать знак + перед примитивным значением какого-либо типа, чтобы привести его к числу.

!!  приводит данные к булевым значениям в соответствии с их истинностью. Первый восклицательный знак определяет истинность значения, затем отрицает его. Потом второй восклицательный знак преобразует значение в исходное значение истинности.

###### Ограничение доступа к переменным и свойствам ######

Задача состоит в том, чтобы сократить время доступа к переменным и свойствам объектов в приложениях.

Причина заключается в том, что при каждом обращении процессору необходимо получить доступ к элементу в памяти, чтобы вычислить его результаты. Следовательно, это действие нужно выполнять как можно реже.

Например, при наличии цикла не нужно писать следующее:

    for (let i = 0; i < arr.length; i++) {}

Лучше использовать данный вариант:

    let length = arr.length;
    for (let i = 0; i < length; i++) {}

Таким образом, на arr.length ссылаются один раз за цикл, а не обращаются к нему на каждой итерации.

###### Самый быстрый способ выполнения цикла по переменным ######

В JavaScript есть несколько способов прохождения через итерируемые объекты. Один из них — старый добрый цикл for. Другие способы включают цикл for...of и метод forEach для массивов. map и filter также проходят по массиву после выполнения операций map и filter. Также есть цикл while.

Из всех способов запуска циклов for является самым быстрым как с, так и без кэширования length. Однако в некоторых случаях оно повышает эффективность.

Некоторые движки браузеров оптимизировали цикл for без кэширования свойства length.

Цикл while с уменьшающимся индексом примерно в 1,5 раза медленнее цикла for.

Цикл forEach в 10 раз медленнее for, поэтому лучше избегать его использования, особенно для больших массивов.

Результаты можно посмотреть здесь.

###### Ограничение доступа к DOM ######

Доступ к DOM — это дорогостоящая операция, поскольку браузер должен получить элемент с веб-страницы, а затем создать из него объект и вернуть его.

Чтобы ограничить доступ к DOM, нужно установить переменную для объектов DOM Node, если они подвергаются манипулированию более одного раза.

Например, чтобы установить текст для следующего HTML-кода:

    <p id='foo'></p>

Можно написать следующий код:

    const setText = (element, textContent) => {
      return new Promise((resolve) => {
        setTimeout(() => {
          element.textContent = textContent;
          resolve();
        }, 3000)
      })
    }

    (async () => {
      const foo = document.querySelector('#foo');
      await setText(foo, 'foo');
      await setText(foo, 'bar');
      await setText(foo, 'baz');
    })();

В приведенном выше фрагменте есть функция, получающая элемент HTML, которым нужно манипулировать, а также текстовое содержимое, которое нужно установить.

Функция setText возвращает промис об установке текста для данного элемента через 3 секунды.

Также у нас есть функция async для установки текста 3 раза. Важный момент: ссылка на элемент передается при каждом вызове. Таким образом, мы избавляемся от необходимости получать элемент с веб-страницы 3 раза, что является дорогостоящей операцией.

###### Уменьшение размера DOM ######

Рендеринг дерева DOM — это медленный процесс. Следовательно, необходимо уменьшить размер дерева. Единственный способ — максимально упростить веб-страницы.

Уменьшение размера DOM ускоряет поиск элементов с помощью таких методов, как querySelector, getElementById или getElementsByTagName.

Кроме того, улучшается производительность рендеринга страниц, поскольку количество загружаемых элементов сокращается.

###### Не объявляйте ненужные переменные ######

При каждом объявлении переменных, браузер должен выделить пространство памяти для них. Следовательно, чтобы уменьшить использование памяти, необходимо сократить количество объявления переменных.

Для примера возьмем следующий HTML-код:

    <div id='foo'>
      <p>
                 
      </p>
    </div>

Чтобы установить текстовое содержимое элемента p, не нужно писать ничего вроде:

    const foo = document.querySelector('#foo');
    const p = foo.querySelector('p');
    p.textContent = 'foo';

поскольку у нас есть 2 переменные. Это означает, что компьютер должен хранить значения еще для 2 переменных JavaScript.

Вместо этого можно сократить объявления переменных с помощью:

    document.querySelector('#foo p').textContent = 'foo';

Используйте метод querySelector, а также связанный метод querySelectorAll, для выбора элементов, поскольку они оба применяют CSS-селекторы для выбора любого узла элемента HTML.

###### Отложенная загрузка сценариев ######

Загрузка файлов JavaScript — дорогостоящая операция. Браузер должен загрузить файл, проанализировать содержимое, а затем преобразовать его в машинный код и запустить.

Браузер загружает один файл построчно, не допуская выполнения других операций. Следовательно, нам нужно отложить эту операцию. Для этого разместите тег script в конце кода. Также можно использовать атрибут defer тега script. Кроме того, сценарии можно запускать после загрузки страницы, создавая элементы script и добавляя их следующим образом:

    window.onload = () => {
      const element = document.createElement("script");
      element.src = "https://code.jquery.com/jquery-1.12.4.min.js";
      document.body.appendChild(element);
    };

Все элементы, загружаемые после загрузки страницы, могут использовать этот метод.

###### Не передавайте строку в «SetInterval» или «SetTimeOut» ######

Рассмотрим следующий код:

    setInterval(  
    "document.getElementById('container').innerHTML += 'My new number: ' + i", 3000  
    );  

Вместо этого передавайте функцию в качестве аргумента.

    setInterval(someFunction, 3000);  
